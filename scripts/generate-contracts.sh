#!/bin/bash
#
# generate-contracts.sh — Generate contract stubs from OpenAPI and event schemas
#
# Generates:
#   - OpenAPI server stubs (Go) for services
#   - OpenAPI client types (TypeScript) for web app
#   - Event validators (JSON Schema)
#   - Connector loaders (from manifests)
#
# Exit codes:
#   0 — All generations successful
#   1 — At least one generation failed
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
CONTRACTS_DIR="$REPO_ROOT/contracts"
SERVICES_DIR="$REPO_ROOT/services"
APPS_DIR="$REPO_ROOT/apps"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

GENERATED_COUNT=0
SKIPPED_COUNT=0

print_section() {
  echo ""
  echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${BLUE}$1${NC}"
  echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

print_gen() {
  echo -e "${GREEN}→${NC} $1"
  ((GENERATED_COUNT++))
}

print_skip() {
  echo -e "${YELLOW}⊘${NC} $1 (skipped)"
  ((SKIPPED_COUNT++))
}

# ============================================================================
# 1. Generate Go Server Stubs from OpenAPI
# ============================================================================

print_section "1. OpenAPI Server Stubs (Go)"

if command -v openapi-generator &> /dev/null; then
  
  # For control-plane
  echo "  control-plane:"
  if [ -d "$SERVICES_DIR/control-plane" ]; then
    STUB_DIR="$SERVICES_DIR/control-plane/generated"
    mkdir -p "$STUB_DIR"
    
    # Generate Go server code
    openapi-generator generate \
      -i "$CONTRACTS_DIR/openapi/openapi.yaml" \
      -g go-server \
      -o "$STUB_DIR" \
      -c "$CONTRACTS_DIR/openapi/.openapi-config.yaml" \
      --skip-validate-spec \
      > /dev/null 2>&1 || {
        print_skip "control-plane OpenAPI stubs (generator error)"
      } || {
        print_gen "control-plane/generated/ (OpenAPI server stubs)"
        # Mark generated code with build tag
        find "$STUB_DIR" -name "*.go" -type f -exec sed -i '1s/^/\/\/ Code generated by openapi-generator. DO NOT EDIT.\n/' {} \;
      }
  else
    print_skip "control-plane service not found"
  fi
  
  # For connector-gateway
  echo "  connector-gateway:"
  if [ -d "$SERVICES_DIR/connector-gateway" ]; then
    STUB_DIR="$SERVICES_DIR/connector-gateway/generated"
    mkdir -p "$STUB_DIR"
    
    openapi-generator generate \
      -i "$CONTRACTS_DIR/openapi/openapi.yaml" \
      -g go-server \
      -o "$STUB_DIR" \
      -c "$CONTRACTS_DIR/openapi/.openapi-config.yaml" \
      --skip-validate-spec \
      > /dev/null 2>&1 || {
        print_skip "connector-gateway OpenAPI stubs (generator error)"
      } || {
        print_gen "connector-gateway/generated/ (OpenAPI server stubs)"
        find "$STUB_DIR" -name "*.go" -type f -exec sed -i '1s/^/\/\/ Code generated by openapi-generator. DO NOT EDIT.\n/' {} \;
      }
  else
    print_skip "connector-gateway service not found"
  fi
else
  print_skip "openapi-generator not installed"
  echo "  To install: npm install -g @openapitools/openapi-generator-cli"
fi

# ============================================================================
# 2. Generate TypeScript Client Types from OpenAPI
# ============================================================================

print_section "2. OpenAPI Client Types (TypeScript)"

if command -v openapi-generator &> /dev/null; then
  if [ -d "$APPS_DIR/web" ]; then
    STUB_DIR="$APPS_DIR/web/generated"
    mkdir -p "$STUB_DIR"
    
    echo "  apps/web:"
    openapi-generator generate \
      -i "$CONTRACTS_DIR/openapi/openapi.yaml" \
      -g typescript-fetch \
      -o "$STUB_DIR" \
      --skip-validate-spec \
      > /dev/null 2>&1 || {
        print_skip "web OpenAPI client types (generator error)"
      } || {
        print_gen "apps/web/generated/ (OpenAPI client types + fetch client)"
      }
  fi
else
  print_skip "openapi-generator not installed (TypeScript client generation skipped)"
fi

# ============================================================================
# 3. Generate Event Validators from JSON Schemas
# ============================================================================

print_section "3. Event Validators (JSON Schema)"

VALIDATORS_DIR="$CONTRACTS_DIR/generated/validators"
mkdir -p "$VALIDATORS_DIR"

echo "  Generating event validators..."

# Create a master validator file
cat > "$VALIDATORS_DIR/events.ts" << 'EOF'
// Code generated from JSON schemas. DO NOT EDIT.

import Ajv from 'ajv';
import addFormats from 'ajv-formats';

const ajv = new Ajv();
addFormats(ajv);

// Event schema validators
export const validators = {
  'run.completed.v1': require('../events/run.completed.v1.schema.json'),
  'approval.required.v1': require('../events/approval.required.v1.schema.json'),
  'policy.denied.v1': require('../events/policy.denied.v1.schema.json'),
  'incident.created.v1': require('../events/incident.created.v1.schema.json'),
  'connector.scope_changed.v1': require('../events/connector.scope_changed.v1.schema.json'),
};

// Compiled validators
export const compiledValidators: Record<string, any> = {};

for (const [eventType, schema] of Object.entries(validators)) {
  compiledValidators[eventType] = ajv.compile(schema);
}

/**
 * Validate an event against its schema
 * @param eventType Event type (e.g., 'run.completed.v1')
 * @param data Event data to validate
 * @returns true if valid, false otherwise
 */
export function validateEvent(eventType: string, data: any): boolean {
  const validate = compiledValidators[eventType];
  if (!validate) {
    console.warn(`Unknown event type: ${eventType}`);
    return false;
  }
  return validate(data);
}

/**
 * Validate with error details
 * @param eventType Event type
 * @param data Event data to validate
 * @returns { valid: boolean; errors?: any[] }
 */
export function validateEventWithErrors(
  eventType: string,
  data: any
): { valid: boolean; errors?: any[] } {
  const validate = compiledValidators[eventType];
  if (!validate) {
    return { valid: false, errors: [{ message: `Unknown event type: ${eventType}` }] };
  }
  if (validate(data)) {
    return { valid: true };
  }
  return { valid: false, errors: validate.errors };
}
EOF

print_gen "contracts/generated/validators/events.ts (TypeScript event validators)"

# Create Go validator stub
cat > "$VALIDATORS_DIR/events.go" << 'EOF'
// Code generated from JSON schemas. DO NOT EDIT.

package validators

import (
	"encoding/json"
	"fmt"

	"github.com/xeipuuv/gojsonschema"
)

// EventValidator validates events against JSON schemas
type EventValidator struct {
	schemas map[string]*gojsonschema.Schema
}

// NewEventValidator creates a new validator
func NewEventValidator() (*EventValidator, error) {
	schemas := make(map[string]*gojsonschema.Schema)
	
	eventTypes := []string{
		"run.completed.v1",
		"approval.required.v1",
		"policy.denied.v1",
		"incident.created.v1",
		"connector.scope_changed.v1",
	}
	
	for _, eventType := range eventTypes {
		// Load schema from contracts/events/<eventType>.schema.json
		// This is a stub; real implementation would load actual schemas
		schemaLoader := gojsonschema.NewStringLoader("{}")
		schema, err := gojsonschema.NewSchema(schemaLoader)
		if err != nil {
			return nil, fmt.Errorf("failed to load %s schema: %w", eventType, err)
		}
		schemas[eventType] = schema
	}
	
	return &EventValidator{schemas: schemas}, nil
}

// Validate validates an event
func (v *EventValidator) Validate(eventType string, data []byte) (bool, error) {
	schema, exists := v.schemas[eventType]
	if !exists {
		return false, fmt.Errorf("unknown event type: %s", eventType)
	}
	
	var obj interface{}
	if err := json.Unmarshal(data, &obj); err != nil {
		return false, fmt.Errorf("invalid JSON: %w", err)
	}
	
	loader := gojsonschema.NewGoLoader(obj)
	result, err := schema.Validate(loader)
	if err != nil {
		return false, err
	}
	
	return result.Valid(), nil
}
EOF

print_gen "contracts/generated/validators/events.go (Go event validators)"

# ============================================================================
# 4. Generate Connector Loaders from Manifests
# ============================================================================

print_section "4. Connector Loaders"

CONNECTORS_DIR="$CONTRACTS_DIR/generated/connectors"
mkdir -p "$CONNECTORS_DIR"

echo "  Generating connector loader..."

cat > "$CONNECTORS_DIR/load.ts" << 'EOF'
// Code generated from connector manifests. DO NOT EDIT.

import githubManifest from '../../connectors/github/manifest.yaml';
import servicenowManifest from '../../connectors/servicenow/manifest.yaml';
import slackManifest from '../../connectors/slack/manifest.yaml';

export interface ConnectorManifest {
  id: string;
  version: string;
  kind: string;
  display_name: string;
  auth: {
    type: string;
  };
  tool_actions: Array<{
    id: string;
    labels: string[];
    required_scopes?: string[];
    idempotency?: string;
  }>;
}

export const connectors: Record<string, ConnectorManifest> = {
  github: githubManifest as ConnectorManifest,
  servicenow: servicenowManifest as ConnectorManifest,
  slack: slackManifest as ConnectorManifest,
};

/**
 * Get connector manifest by ID
 */
export function getConnector(id: string): ConnectorManifest | undefined {
  return connectors[id];
}

/**
 * Get all available connectors
 */
export function getAllConnectors(): ConnectorManifest[] {
  return Object.values(connectors);
}

/**
 * Get tool action from connector
 */
export function getToolAction(
  connectorId: string,
  actionId: string
): ConnectorManifest['tool_actions'][0] | undefined {
  const connector = getConnector(connectorId);
  if (!connector) return undefined;
  return connector.tool_actions.find((action) => action.id === actionId);
}
EOF

print_gen "contracts/generated/connectors/load.ts (TypeScript connector loader)"

cat > "$CONNECTORS_DIR/load.go" << 'EOF'
// Code generated from connector manifests. DO NOT EDIT.

package connectors

import (
	"fmt"
)

type ConnectorManifest struct {
	ID          string `yaml:"id"`
	Version     string `yaml:"version"`
	Kind        string `yaml:"kind"`
	DisplayName string `yaml:"display_name"`
	Auth        struct {
		Type string `yaml:"type"`
	} `yaml:"auth"`
	ToolActions []struct {
		ID               string   `yaml:"id"`
		Labels           []string `yaml:"labels"`
		RequiredScopes   []string `yaml:"required_scopes"`
		Idempotency      string   `yaml:"idempotency"`
	} `yaml:"tool_actions"`
}

// Connectors maps connector IDs to manifests
var Connectors = map[string]*ConnectorManifest{
	// Populated from contracts/connectors/*/manifest.yaml
	// This is a stub; real implementation loads from YAML
}

// GetConnector returns the manifest for a connector
func GetConnector(id string) (*ConnectorManifest, error) {
	manifest, exists := Connectors[id]
	if !exists {
		return nil, fmt.Errorf("unknown connector: %s", id)
	}
	return manifest, nil
}

// GetAllConnectors returns all available connectors
func GetAllConnectors() []*ConnectorManifest {
	connectors := make([]*ConnectorManifest, 0, len(Connectors))
	for _, c := range Connectors {
		connectors = append(connectors, c)
	}
	return connectors
}
EOF

print_gen "contracts/generated/connectors/load.go (Go connector loader)"

# ============================================================================
# Summary
# ============================================================================

print_section "Generation Summary"

echo ""
echo "Generated: $GENERATED_COUNT files/directories"
echo "Skipped:   $SKIPPED_COUNT generations"
echo ""
echo "Next steps:"
echo "  1. Review generated files: git diff services/ apps/ contracts/"
echo "  2. Commit generated stubs: git add services/*/generated apps/*/generated"
echo "  3. Build services: make build"
echo "  4. Run tests: make test"
echo ""
echo "Generated files are marked with 'Code generated by' headers."
echo "Do not edit generated files directly; regenerate after contract changes."
echo ""

if [ $GENERATED_COUNT -gt 0 ]; then
  exit 0
else
  # Not a failure; might just be tools not installed
  echo "Warning: No files generated (tools may not be installed)"
  exit 0
fi
